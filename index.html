<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
  :root{
    --bg:#f6f7f9;
    --panel:#ffffff;
    --text:#111318;
    --muted:#5b616b;
    --border:rgba(0,0,0,.10);
    --shadow:0 8px 24px rgba(0,0,0,.08);
    color-scheme: light dark;
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#0b0c10;
      --panel:#12131a;
      --text:#e7e7e7;
      --muted:#a7a7a7;
      --border:rgba(255,255,255,.12);
      --shadow:0 8px 28px rgba(0,0,0,.35);
    }
  }

  *{ box-sizing:border-box }
  body{
    margin:0;
    font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:var(--bg);
    color:var(--text);
    min-height:100svh;
    display:grid;
    place-items:center;
    padding:24px;
  }
  .card{ width:100%; max-width:920px; background:var(--panel); border:1px solid var(--border); border-radius:16px; box-shadow:var(--shadow); padding:20px }

  header{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:4px 4px 14px; border-bottom:1px dashed var(--border) }
  h1{ margin:0; font-size:clamp(22px,3.5vw,28px); font-weight:800; letter-spacing:.2px }
  .links{ display:flex; gap:10px; flex-wrap:wrap }
  .btn{ appearance:none; border:1px solid var(--border); background:transparent; color:inherit; padding:10px 14px; border-radius:10px; text-decoration:none; font-weight:600; transition:background .15s ease, transform .06s ease, border-color .15s ease }
  .btn:hover{ background:rgba(127,127,127,.08); transform:translateY(-1px) }

  .layout{ display:grid; gap:16px; padding-top:16px; grid-template-columns: 260px 1fr }
  @media (max-width: 740px){ .layout{ grid-template-columns: 1fr } }

  .tabs{ display:flex; flex-direction:column; gap:8px }
  .tabs h2{ margin:0 0 6px; font-size:14px; font-weight:700; letter-spacing:.08em; text-transform:uppercase; color:var(--muted) }
  .tab{ display:flex; align-items:center; justify-content:space-between; width:100%; padding:12px 14px; border:1px solid var(--border); border-radius:10px; background:transparent; color:inherit; text-align:left; font-weight:600; cursor:pointer }
  .tab[aria-selected="true"]{ outline:2px solid transparent; border-color:color-mix(in srgb, var(--text) 14%, transparent); background:color-mix(in srgb, var(--text) 6%, transparent) }
  .tab:focus-visible{ outline:2px solid color-mix(in srgb, var(--text) 30%, transparent) }

  .panel{ border:1px solid var(--border); border-radius:12px; padding:16px; min-height:180px }
  .panel h3{ margin:0 0 6px; font-size:18px }
  .panel p{ margin:.5rem 0; color:var(--muted) }

  @media (max-width:740px){ .tabs{ order:-1 } .tab{ min-height:44px } }

  /* --- Minimal circuit sim styles --- */
  .sim{ width:100%; max-width:920px; margin-bottom:16px }
  .circuit{ width:100%; height:560px; display:block }
  .wire{ stroke: var(--wire, color-mix(in srgb, var(--text) 28%, transparent)); stroke-width:3; fill:none; stroke-linecap:butt }
  .wire.high{ stroke: var(--wire-hi, #10b981) }
  .node{ fill: color-mix(in srgb, var(--text) 28%, transparent) }
  .node.high{ fill: var(--wire-hi, #10b981) }
  .dangling{ fill:none; stroke: var(--wire, color-mix(in srgb, var(--text) 28%, transparent)); stroke-width:2 }
  .bit-rect{ fill: var(--panel); stroke: var(--border) }
  .bit-label{ font-weight:700; font-size:16px; dominant-baseline:middle; text-anchor:middle; user-select:none; pointer-events:none }
  .bit{ cursor:pointer }
  .bit:focus-visible .bit-rect{ stroke: color-mix(in srgb, var(--text) 40%, transparent); stroke-width:3 }
  /* shaped gate outlines */
  .gate-shape{ stroke: var(--border); stroke-width:2; fill:none }
</style>

<!-- Canvas for circuits (left empty; user builds via API) -->
<div class="sim" aria-label="Circuit canvas">
  <svg class="circuit" viewBox="0 0 1600 560" role="img" aria-labelledby="circ-title">
    <title id="circ-title">Circuit Canvas</title>
  </svg>
</div>

<main class="card" role="main">
  <header>
    <h1>Kevin Pugliese</h1>
    <nav aria-label="Social">
      <div class="links">
        <a class="btn" href="https://github.com/Puglord6383" target="_blank" rel="noopener">GitHub</a>
        <a class="btn" href="https://www.linkedin.com/in/kevingpugliese" target="_blank" rel="noopener">LinkedIn</a>
      </div>
    </nav>
  </header>

  <section class="layout">
    <aside class="tabs" role="tablist" aria-label="Projects">
      <h2>Projects</h2>
      <a class="tab" role="tab" id="tab-p1" href="#panel-p1" aria-controls="panel-p1" aria-selected="true">Project 1</a>
      <a class="tab" role="tab" id="tab-p2" href="#panel-p2" aria-controls="panel-p2" aria-selected="false">Project 2</a>
      <a class="tab" role="tab" id="tab-p3" href="#panel-p3" aria-controls="panel-p3" aria-selected="false">Project 3</a>
    </aside>

    <section class="panel">
      <article id="panel-p1" role="tabpanel" aria-labelledby="tab-p1">
        <h3>Project 1</h3>
        <p>description</p>
      </article>

      <article id="panel-p2" role="tabpanel" aria-labelledby="tab-p2" hidden>
        <h3>Project 2</h3>
        <p>description</p>
      </article>

      <article id="panel-p3" role="tabpanel" aria-labelledby="tab-p3" hidden>
        <h3>Project 3</h3>
        <p>description</p>
      </article>
    </section>
  </section>
</main>

<script>
  (function(){
    // Tab logic (unchanged)
    const tabs = Array.from(document.querySelectorAll('[role="tab"]'));
    const panels = Array.from(document.querySelectorAll('[role="tabpanel"]'));
    if (tabs.length) {
      function activateTab(tab, setHash = true) {
        const targetId = tab.getAttribute('aria-controls');
        tabs.forEach(t => t.setAttribute('aria-selected', String(t === tab)));
        panels.forEach(p => p.hidden = (p.id !== targetId));
        if (setHash) history.replaceState(null, '', '#' + targetId);
        tab.focus();
      }
      tabs.forEach((tab, i) => {
        tab.addEventListener('click', () => activateTab(tab, true));
        tab.addEventListener('keydown', (e) => {
          const { key } = e; let idx = i;
          if (key === 'ArrowRight' || key === 'ArrowDown') { idx = (i + 1) % tabs.length; e.preventDefault(); tabs[idx].focus(); }
          if (key === 'ArrowLeft'  || key === 'ArrowUp')   { idx = (i - 1 + tabs.length) % tabs.length; e.preventDefault(); tabs[idx].focus(); }
          if (key === 'Home') { e.preventDefault(); tabs[0].focus(); }
          if (key === 'End')  { e.preventDefault(); tabs[tabs.length - 1].focus(); }
          if (key === 'Enter' || key === ' ') { e.preventDefault(); activateTab(document.activeElement, true); }
        });
      });
      function initFromHash(){
        const id = location.hash.slice(1);
        const match = id && document.getElementById(id);
        if (match && match.getAttribute('role') === 'tabpanel') {
          const tab = document.querySelector('[aria-controls="' + id + '"]');
          if (tab) activateTab(tab, false);
        } else {
          const initial = tabs.find(t => t.getAttribute('aria-selected') === 'true') || tabs[0];
          if (initial) activateTab(initial, false);
        }
      }
      window.addEventListener('hashchange', initFromHash, { passive: true });
      initFromHash();
    }
  })();
</script>

<script>
  // -------------------------
  //  MINIMAL CIRCUIT LIBRARY
  //  Public API = window.Circuit
  //  Gates: BIT, AND, OR, NOT (2-input)
  //  Wires connect by pin refs: "ID.pin"
  // -------------------------
  (function(){
    const svg = document.querySelector('.circuit');
    const NS = 'http://www.w3.org/2000/svg';

    // Create layers: gates under wires, nodes above wires
    const gWires = make('g', {id:'wires'}); svg.appendChild(gWires);
    const gGates = make('g', {id:'gates'}); svg.appendChild(gGates);
    const gNodes = make('g', {id:'nodes'}); svg.appendChild(gNodes);

    const R = { node:4, bubble:5 };
    const sim = { comps:new Map(), pins:new Map(), wires:[], R, layers:{ gGates, gWires, gNodes } };

    function make(tag, attrs){ const n=document.createElementNS(NS, tag); if(attrs){ for(const k in attrs) n.setAttribute(k, attrs[k]); } return n; }
    function attr(n, attrs){ for(const k in attrs) n.setAttribute(k, attrs[k]); return n; }

    // ---- Pins ----
    function pinKey(id, name){ return `${id}.${name}`; }
    function addPin(id, name, x, y, r=R.node){
      const key = pinKey(id,name);
      const circle = make('circle', { id:`pin-${id}-${name}`, class:'node', cx:x, cy:y, r });
      gNodes.appendChild(circle);
      const p = { id:key, x, y, r, v:0, dr:false, el:circle };
      sim.pins.set(key, p);
      return key;
    }
    function getPin(ref){
      if (!ref) throw new Error('Missing pin ref');
      const key = typeof ref === 'string' ? ref : (ref.id || ref);
      const p = sim.pins.get(key);
      if (!p) throw new Error('Pin not found: ' + key);
      return p;
    }

    // ---- Wires ----
    function tangent(a, b){
      // Return [x1,y1,x2,y2] that stop exactly at dot tangents (butt caps)
      const dir = (b.x >= a.x) ? 1 : -1;
      const x1 = a.x + dir * a.r;
      const x2 = b.x - dir * b.r;
      return [x1, a.y, x2, b.y];
    }
    function wirePoints(fromRef, toRef, via){
      const a = getPin(fromRef), b = getPin(toRef);
      const pts = [];
      // No vias â†’ draw a single straight horizontal OR vertical segment with tangent offsets
      if (!via || via.length === 0){
        if (Math.abs(a.x - b.x) < 1e-6){
          // vertical
          const dirY = (b.y >= a.y) ? 1 : -1;
          const y1 = a.y + dirY * a.r;
          const y2 = b.y - dirY * b.r;
          pts.push([a.x, y1], [b.x, y2]);
        } else {
          // horizontal/diagonal fallback (horizontal by construction in our use)
          const dir = (b.x >= a.x) ? 1 : -1;
          const x1 = a.x + dir * a.r;
          const x2 = b.x - dir * b.r;
          pts.push([x1, a.y], [x2, b.y]);
        }
      } else {
        // With vias: respect axis of first/last legs for clean tangents
        const f = { x: via[0].x, y: via[0].y };
        if (Math.abs(f.x - a.x) < 1e-6){
          // first leg vertical
          const dirY = (f.y >= a.y) ? 1 : -1;
          pts.push([a.x, a.y + dirY * a.r]);
        } else {
          // first leg horizontal
          const dir = (f.x >= a.x) ? 1 : -1;
          pts.push([a.x + dir * a.r, a.y]);
        }
        via.forEach(p=>pts.push([p.x,p.y]));
        const l = via[via.length-1];
        if (Math.abs(b.x - l.x) < 1e-6){
          // last leg vertical
          const dirY = (b.y >= l.y) ? 1 : -1;
          pts.push([b.x, b.y - dirY * b.r]);
        } else {
          // last leg horizontal
          const dir = (b.x >= l.x) ? 1 : -1;
          pts.push([b.x - dir * b.r, b.y]);
        }
      }
      return pts;
    }
    function addWire(fromRef, toRef, via){
      const pts = wirePoints(fromRef, toRef, via);
      let el;
      if (pts.length === 2){
        el = make('line', { class:'wire', x1:pts[0][0], y1:pts[0][1], x2:pts[1][0], y2:pts[1][1] });
      } else {
        el = make('polyline', { class:'wire', points: pts.map(p=>p.join(',')).join(' ') });
      }
      gWires.appendChild(el);
      const w = { from: typeof fromRef==='string'?fromRef:fromRef.id, to: typeof toRef==='string'?toRef:toRef.id, via, el };
      sim.wires.push(w);
      return w;
    }
    function addDangling(id, name, x, y, r=R.node){ return addPin(id, name, x, y, r); }
    function addJunction(id, x, y, r=R.node){ return addPin(id, 'j', x, y, r); }

    // ---- Gates ----
    function addBit(id, x, y){
      const g = make('g', { id, tabindex:0, class:'bit', 'aria-label':`Bit ${id}` });
      const rect = make('rect', { class:'bit-rect', x, y, rx:8, ry:8, width:64, height:48 });
      const tx = make('text', { class:'bit-label', x:x+32, y:y+24 }); tx.textContent='0';
      const out = addPin(id, 'out', x+64+R.node, y+24, R.node);
      g.append(rect, tx);
      svg.appendChild(g);
      const comp = { id, kind:'BIT', pins:{ out }, els:{ g, rect, tx }, state:{ val:0 } };
      sim.comps.set(id, comp);
      g.addEventListener('click', ()=>{ comp.state.val^=1; tx.textContent=String(comp.state.val); render(); });
      g.addEventListener('keydown', (e)=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); comp.state.val^=1; tx.textContent=String(comp.state.val); render(); }});
      return comp;
    }
    function addAND(id, x, y, s=1){
      const w=72*s, h=72*s, r=36*s;
      const path = make('path', { class:'gate-shape', d:`M${x} ${y} H${x+36*s} A${r} ${r} 0 0 1 ${x+36*s} ${y+h} H${x} Z` });
      gGates.appendChild(path);
      const inA = addPin(id,'inA', x, y+8*s, R.node);
      const inB = addPin(id,'inB', x, y+64*s, R.node);
      const out = addPin(id,'out', x+w, y+h/2, R.node);
      const comp = { id, kind:'AND', pins:{ inA, inB, out }, els:{ path }, s };
      sim.comps.set(id, comp); return comp;
    }
    function addOR(id, x, y, s=1){
      const w=72*s, h=72*s;
      const path = make('path', { class:'gate-shape', d:`M${x} ${y} C ${x+24*s} ${y}, ${x+60*s} ${y+12*s}, ${x+w} ${y+h/2} C ${x+60*s} ${y+h-12*s}, ${x+24*s} ${y+h}, ${x} ${y+h} C ${x+12*s} ${y+h-16*s}, ${x+12*s} ${y+16*s}, ${x} ${y}` });
      gGates.appendChild(path);
      const inA = addPin(id,'inA', x+4*s, y+8*s, R.node);
      const inB = addPin(id,'inB', x+4*s, y+64*s, R.node);
      const out = addPin(id,'out', x+w, y+h/2, R.node);
      const comp = { id, kind:'OR', pins:{ inA, inB, out }, els:{ path }, s };
      sim.comps.set(id, comp); return comp;
    }
    function addNOT(id, x, y, s=1){
      const triW=44*s, h=72*s;
      const poly = make('polygon', { points: `${x},${y+12*s} ${x},${y+h-12*s} ${x+triW},${y+h/2}`, fill:'none', style:'stroke: var(--border); stroke-width:2' });
      gGates.appendChild(poly);
      const inn = addPin(id,'in', x, y+h/2, R.node);
      const out = addPin(id,'out', x+triW+R.bubble, y+h/2, R.bubble);
      const comp = { id, kind:'NOT', pins:{ in:inn, out }, els:{ poly }, s };
      sim.comps.set(id, comp); return comp;
    }
    // Simple output display block that shows "1: Prime" or "0: Composite"
    function addDisplay(id, x, y, w=132, h=36){
      const g = make('g', { id, class:'display' });
      const rect = make('rect', { class:'bit-rect', x, y, rx:8, ry:8, width:w, height:h });
      const tx = make('text', { class:'bit-label', x: x + w/2, y: y + h/2 });
      tx.textContent = '0: Composite';
      const input = addPin(id, 'in', x, y + h/2, R.node);
      g.appendChild(rect); g.appendChild(tx);
      gGates.appendChild(g);
      const comp = { id, kind:'DISP', pins:{ in: input }, els:{ g, rect, tx }, box:{ x, y, w, h } };
      sim.comps.set(id, comp);
      return comp;
    }

    // ---- Evaluation ----
    function clearVals(){ sim.pins.forEach(p=>{ p.v=0; p.dr=false; }); }
    function evalOnce(){
      // wires propagate (fan-out allowed)
      for(const w of sim.wires){ const a=sim.pins.get(w.from); const b=sim.pins.get(w.to); if (a && b){ b.v = a.v ? 1 : 0; b.dr = !!a.dr; } }
      // gates compute
      for(const comp of sim.comps.values()){
        switch(comp.kind){
          case 'BIT': { const o=sim.pins.get(comp.pins.out); o.v = comp.state.val ? 1 : 0; o.dr = true; break; }
          case 'AND': { const aP=sim.pins.get(comp.pins.inA), bP=sim.pins.get(comp.pins.inB); const o=sim.pins.get(comp.pins.out); o.v = (aP.v && bP.v) ? 1 : 0; o.dr = !!(aP.dr || bP.dr); break; }
          case 'OR': { const aP=sim.pins.get(comp.pins.inA), bP=sim.pins.get(comp.pins.inB); const o=sim.pins.get(comp.pins.out); o.v = (aP.v || bP.v) ? 1 : 0; o.dr = !!(aP.dr || bP.dr); break; }
          case 'NOT': { const i=sim.pins.get(comp.pins.in); const o=sim.pins.get(comp.pins.out); o.v = i.v ? 0 : 1; o.dr = !!i.dr; break; }
        }
      }
    }
    function render(){
      clearVals();
      // prime seeds: bit sources
      for(const comp of sim.comps.values()) if(comp.kind==='BIT'){ const o=sim.pins.get(comp.pins.out); o.v = comp.state.val?1:0; o.dr = true; }
      // settle a few rounds (acyclic combinational)
      for (let i=0;i<16;i++) evalOnce();
      // visuals
      sim.pins.forEach(p=> p.el.classList.toggle('high', !!(p.v && p.dr))); 
      for(const w of sim.wires){ const a=sim.pins.get(w.from); w.el.classList.toggle('high', !!(a && a.v && a.dr)); }
      // update display blocks
      for(const comp of sim.comps.values()){
        if (comp.kind==='DISP'){
          const v = sim.pins.get(comp.pins.in).v ? 1 : 0;
          comp.els.tx.textContent = v ? '1: Prime' : '0: Composite';
        }
      }
    }

    // ---- Declarative builder (for you) ----
    function build(spec){
      // spec = { nodes:[{kind,id,x,y}], wires:[[from,to,via?], ...] }
      if(spec.nodes){
        for(const n of spec.nodes){
          switch(n.kind){
            case 'BIT': addBit(n.id, n.x, n.y); break;
            case 'AND': addAND(n.id, n.x, n.y); break;
            case 'OR' : addOR(n.id, n.x, n.y); break;
            case 'NOT': addNOT(n.id, n.x, n.y); break;
          }
        }
      }
      if(spec.wires){
        for(const w of spec.wires){ addWire(w[0], w[1], w[2]); }
      }
      render();
      return api;
    }

    function clear(){
      // remove all svg children from layers and reset maps
      [gGates,gWires,gNodes].forEach(g=>{ while(g.firstChild) g.removeChild(g.firstChild); });
      sim.comps.clear(); sim.pins.clear(); sim.wires.length = 0;
    }

    function label(text, x, y){ const t=make('text',{class:'bit-label', x, y}); t.textContent=text; svg.appendChild(t); return t; }
    function setBit(id, v){ const c=sim.comps.get(id); if(c&&c.kind==='BIT'){ c.state.val = v?1:0; c.els.tx.textContent=String(c.state.val); render(); }}
    function get(ref){ return getPin(ref); }

    // Public API
    const api = window.Circuit = {
      // low-level
      addBit, addAND, addOR, addNOT, addDangling, addJunction, addWire, label, addDisplay,
      // declarative
      build, clear,
      // helpers
      pin: get, setBit, render,
      // internals (exposed for power users)
      _sim: sim
    };

  })();
</script>

<script>
  // Six-line setup with clean input rails (20px apart) â€” no XOR yet.
  // Rails: A,B,C,D vertical buses; each rail ends at its topmost/bottommost tap.
  (function(){
    if(!window.Circuit) return; const C = window.Circuit; C.clear();
    const S = 0.75; // compact gate size

    // --- Inputs stacked on the left ---
    C.addBit('A', 88, 164); // A.out yâ‰ˆ38
    C.addBit('B', 88, 234); // B.out yâ‰ˆ188
    C.addBit('C', 88, 310); // C.out yâ‰ˆ338
    C.addBit('D', 88, 385); // D.out yâ‰ˆ488

    // --- Gate columns ---
    const COL = { RAIL:200, AND1:300, AND2:406, OUT:510 };
    const RAILS = { A:COL.RAIL, B:COL.RAIL+20, C:COL.RAIL+40, D:COL.RAIL+60 };

    // Internal bookkeeping for rail extents & decorative rail lines
    const taps = { A:[C._sim.pins.get('A.out').y], B:[C._sim.pins.get('B.out').y], C:[C._sim.pins.get('C.out').y], D:[C._sim.pins.get('D.out').y] };
    const railEls = [];

    // Helper: orthogonal feed from SOURCE PIN (A/B/C/D) via its rail to a DEST PIN
    function feedFrom(sig, srcRef, destPin){
      const src = C._sim.pins.get(srcRef); const dst = C._sim.pins.get(destPin);
      const rx = RAILS[sig];
      taps[sig].push(dst.y);
      const approachX = dst.x - dst.r - 6; // ensure last hop is horizontal
      C.addWire(srcRef, destPin, [ {x:rx, y:src.y}, {x:rx, y:dst.y}, {x:approachX, y:dst.y} ]);
    }

    // Helper: orthogonal run between two gate pins
    function run(fromRef, toRef, xMid){
      const a = C._sim.pins.get(fromRef), b = C._sim.pins.get(toRef);
      const xm = xMid ?? Math.min(a.x,b.x) + 40;
      const approachX = b.x - b.r - 6;
      C.addWire(fromRef, toRef, [ {x:xm, y:a.y}, {x:xm, y:b.y}, {x:approachX, y:b.y} ]);
    }

    // Helper: draw decorative vertical rail and keep it highlighted with the source bit
    function drawRails(){
      const svg = document.querySelector('.circuit');
      const NS = 'http://www.w3.org/2000/svg';
      function make(tag, attrs){ const n=document.createElementNS(NS, tag); for(const k in attrs) n.setAttribute(k, attrs[k]); return n; }
      const layer = svg.querySelector('#wires'); // wires layer exists
      [['A','A.out'],['B','B.out'],['C','C.out'],['D','D.out']].forEach(([sig,srcId])=>{
        const ys = taps[sig]; const y1 = Math.min(...ys), y2 = Math.max(...ys);
        const x = RAILS[sig];
        const rail = make('line', { x1:x, y1:y1, x2:x, y2:y2, class:'wire' });
        layer.appendChild(rail);
        railEls.push({ el: rail, src: srcId });
      });
      // Patch render() to also highlight rails
      const origRender = C.render; C.render = function(){
        if (origRender) origRender();
        railEls.forEach(r=>{ const p=C._sim.pins.get(r.src); if(!p) return; r.el.classList.toggle('high', !!p.v); });
      };
    }

    // --- Base ANDs ---
    // AND1: A & C
    const AND1 = C.addAND('AND1', COL.AND1, 160, S);
    feedFrom('A','A.out', AND1.pins.inA);
    feedFrom('C','C.out', AND1.pins.inB);

    // AND2: B & C
    const AND2 = C.addAND('AND2', COL.AND1, 220, S);
    feedFrom('B','B.out', AND2.pins.inA);
    feedFrom('C','C.out', AND2.pins.inB);

    // AND3: B & D
    const AND3 = C.addAND('AND3', COL.AND1, 280, S);
    feedFrom('B','B.out', AND3.pins.inA);
    feedFrom('D','D.out', AND3.pins.inB);

    // AND4: A & B â†’ AND4B with D
    const AND4 = C.addAND('AND4', COL.AND1, 340, S);
    feedFrom('A','A.out', AND4.pins.inA);
    feedFrom('B','B.out', AND4.pins.inB);

    const AND4B = C.addAND('AND4B', COL.AND2 - 20, 361, S);
    run(AND4.pins.out, AND4B.pins.inA, COL.AND2-40);
    C.addWire('D.out', AND4B.pins.inB);

    // AND5: B & C â†’ AND5B with D
    const AND5 = C.addAND('AND5', COL.AND1, 424, S);
    feedFrom('B','B.out', AND5.pins.inA);
    feedFrom('C','C.out', AND5.pins.inB);

    const AND5B = C.addAND('AND5B', COL.AND2 - 20, 445, S);
    run(AND5.pins.out, AND5B.pins.inA, COL.AND2-40);
    feedFrom('D','D.out', AND5B.pins.inB);

    // Draw the rails now that all taps are known
    drawRails();

    // --- Expose the six outputs to the right (straight right from each source) ---
    function exposeSimple(pinRef, label){
      const p = C._sim.pins.get(pinRef);
      const secondOutX = C._sim.pins.get(AND4B.pins.out).x; // reference = 2nd column out pin
      const xOut = secondOutX + 50; // ~50px past 2nd column
      const OUT = C.addDangling('OUT', label, xOut, p.y);
      // short, equal-length stubs
      C.addWire(pinRef, OUT, [ {x:xOut-40, y:p.y} ]);
      
      
    }// --- XOR stage setup: NOTs tacked to IN1 and AND1 lines, behind-nodes only, no extra dots ---
    (function(){
      const S = 0.75, h = 72*S; // NOT height â‰ˆ54
      const pin = r=>C._sim.pins.get(r);

      // Determine IN1 tap (40px above AND1 output along B rail)
      const yAND1 = pin(AND1.pins.out).y;
      const SHIFT = 40;
      const yIN1 = yAND1 - 40 - SHIFT;

      // Place NOTs to the right of second column outputs in a consistent column
      const xNot = COL.AND2 + 120;

      // --- NOT for IN1 ---
      const N_IN1 = C.addNOT('X1_NOT_IN1', xNot, yIN1 - h/2, S);
      // Required behind-node 30px left of this NOT
      const TOP_BEHIND = C.addJunction('X1_TOP_BEHIND', xNot - 30, yIN1);
      // Route B.out up the B rail INTO the behind node, then into the NOT
      const b = pin('B.out');
      const pTop = pin(TOP_BEHIND);
      C.addWire('B.out', TOP_BEHIND, [ {x:RAILS.B, y:b.y}, {x:RAILS.B, y:yIN1}, {x:pTop.x, y:yIN1} ]);
      C.addWire(TOP_BEHIND, N_IN1.pins.in, [ {x:xNot-6, y:yIN1} ]);
      

      // --- NOT for AND1 ---
      const yA1 = yAND1 - SHIFT;
      const N_A1 = C.addNOT('X1_NOT_A1', xNot, yA1 - h/2, S);
      C.addWire(AND1.pins.out, N_A1.pins.in, [ {x:xNot-6, y:yA1} ]);
      // Required behind-node 60px left of this NOT (no wire to it yet)
      const BOT_BEHIND = C.addJunction('X1_BOT_BEHIND', xNot - 60, yA1);

      // --- Two ANDs aligned to the NOT outputs ---
      const out1 = pin(N_IN1.pins.out); // yIN1
      const out2 = pin(N_A1.pins.out);  // yA1

      const topANDx = out1.x + 30;           // ~30px horizontal after NOT
      const topANDy = out1.y - 64*S;         // so inB aligns to out1.y
      const X1_AND_TOP = C.addAND('X1_AND_TOP', topANDx, topANDy, S);
      C.addWire(N_IN1.pins.out, X1_AND_TOP.pins.inB);

      const botANDx = out2.x + 30;
      const botANDy = out2.y - 8*S;          // so inA aligns to out2.y
      const X1_AND_BOT = C.addAND('X1_AND_BOT', botANDx, botANDy, S);
      C.addWire(N_A1.pins.out, X1_AND_BOT.pins.inA);

      // TOP_BEHIND vertical down to bottom AND's bottom input
      const xTopSpine = pin(TOP_BEHIND).x;
      const yBotInB = pin(X1_AND_BOT.pins.inB).y;
      const J_SPINE_BOT = C.addJunction('X1_SPINE_BOT', xTopSpine, yBotInB);
      C.addWire(TOP_BEHIND, J_SPINE_BOT);
      C.addWire(J_SPINE_BOT, X1_AND_BOT.pins.inB);

      // Draw a vertical spine UP from the 60px-behind bottom node, and create a node aligned with the TOP AND's top input
      const xSpine = xNot - 60;   // same x as 60px-behind node
      const yBot   = yA1;         // bottom NOT line
      const yTopAND = pin(X1_AND_TOP.pins.inA).y; // align with top AND's top pin
      const J_SPINE_TOP = C.addJunction('X1_SPINE_TOP', xSpine, yTopAND);
      // single vertical run; let wirePoints handle tangents
      C.addWire(BOT_BEHIND, J_SPINE_TOP);
      // feed the top AND input from the new node (rightward)
      C.addWire(J_SPINE_TOP, X1_AND_TOP.pins.inA);
      // OR (module 1): 20px to the right of the AND pair, L-shaped feeds
      {
        const oT = C._sim.pins.get(X1_AND_TOP.pins.out);
        const oB = C._sim.pins.get(X1_AND_BOT.pins.out);
        const S = 0.75; const mid = (oT.y + oB.y)/2; const yOr = mid - 36*S;
        const xOr = oT.x + 20; // ~20px to the right of AND outputs
        const X1_OR = C.addOR('X1_XOR_OR', xOr, yOr, S);
        const iA = C._sim.pins.get(X1_OR.pins.inA);
        const iB = C._sim.pins.get(X1_OR.pins.inB);
        // L-shape: down/up to the OR input Y, then right into the input
        C.addWire(X1_AND_TOP.pins.out, X1_OR.pins.inA, [ {x:oT.x, y:iA.y}, {x:iA.x-6, y:iA.y} ]);
        C.addWire(X1_AND_BOT.pins.out, X1_OR.pins.inB, [ {x:oB.x, y:iB.y}, {x:iB.x-6, y:iB.y} ]);
      }
      // re-route AND1 â†’ NOT through the behind node so the branch carries the signal
      (function(){
        const inRef = N_A1.pins.in;
        for (let i = C._sim.wires.length - 1; i >= 0; i--) {
          const w = C._sim.wires[i];
          if (w.from === 'AND1.out' && w.to === inRef) {
            w.el.remove();
            C._sim.wires.splice(i,1);
          }
        }
        const pAndOut = C._sim.pins.get(AND1.pins.out);
        const pBotJ  = C._sim.pins.get(BOT_BEHIND);
        // L-shape: go UP 40px, then RIGHT into the behind node (no diagonal)
        C.addWire(AND1.pins.out, BOT_BEHIND, [
          { x: pAndOut.x, y: pAndOut.y - 40 },
          { x: pBotJ.x,   y: pAndOut.y - 40 }
        ]);
        C.addWire(BOT_BEHIND, inRef);
      })();
    })();

    // --- XOR Module 2: AND2 (top) XOR AND3 (bottom) ---
    (function(){
      const S = 0.75, h = 72*S; const pin = r=>C._sim.pins.get(r);
      const xNot = COL.AND2 + 120;
      const topRef = AND2.pins.out, botRef = AND3.pins.out;
      const pTop = pin(topRef), pBot = pin(botRef); if(!pTop || !pBot) { C.render && C.render(); return; }

      // NOTs placed in the same x column â€” match Module 1 NOT spacing (â‰ˆ 40px apart)
      let sep1 = 40; // default to module-1 spacing
      const pM1a = C._sim.pins.get('X1_NOT_A1.in');
      const pM1b = C._sim.pins.get('X1_NOT_IN1.in');
      if (pM1a && pM1b) sep1 = Math.abs(pM1a.y - pM1b.y);
      const mid2 = (pTop.y + pBot.y) / 2;
      const yTopT = mid2 - sep1/2;
      const yBotT = mid2 + sep1/2;

      // Top NOT and 30px-behind node
      const N2_TOP = C.addNOT('X2_NOT_TOP', xNot, yTopT - h/2, S);
      const TOP2 = C.addJunction('X2_TOP_BEHIND', xNot - 30, yTopT);
      // Bend directly from AND2.out: vertical to yTopT, then right into the behind node
      C.addWire(topRef, TOP2, [ {x: pin(topRef).x, y: yTopT}, {x:xNot-30, y:yTopT} ]);
      C.addWire(TOP2, N2_TOP.pins.in, [ {x:xNot-6, y:yTopT} ]);

      // Bottom NOT and 60px-behind node
      const N2_BOT = C.addNOT('X2_NOT_BOT', xNot, yBotT - h/2, S);
      const BOT2 = C.addJunction('X2_BOT_BEHIND', xNot - 60, yBotT);
      // Bend directly from AND3.out: vertical to yBotT, then right into the behind node
      C.addWire(botRef, BOT2, [ {x: pin(botRef).x, y: yBotT}, {x:xNot-60, y:yBotT} ]);
      C.addWire(BOT2, N2_BOT.pins.in, [ {x:xNot-6, y:yBotT} ]);

      // ANDs aligned for perfect horizontals from NOT outputs
      const oTop = pin(N2_TOP.pins.out), oBot = pin(N2_BOT.pins.out);
      const X2_AND_TOP = C.addAND('X2_AND_TOP', oTop.x + 30, oTop.y - 64*S, S);
      const X2_AND_BOT = C.addAND('X2_AND_BOT', oBot.x + 30, oBot.y - 8*S,  S);
      C.addWire(N2_TOP.pins.out, X2_AND_TOP.pins.inB);
      C.addWire(N2_BOT.pins.out, X2_AND_BOT.pins.inA);

      // Spines: bottom behind-node up to top AND (inA), and top behind-node down to bottom AND (inB)
      // Spines without extra nodes (only the 30/60px behind-NOT dots remain)
      C.addWire(BOT2, X2_AND_TOP.pins.inA, [
        { x: xNot - 60, y: C._sim.pins.get(BOT2).y },
        { x: xNot - 60, y: C._sim.pins.get(X2_AND_TOP.pins.inA).y }
      ]);
      C.addWire(TOP2, X2_AND_BOT.pins.inB, [
        { x: xNot - 30, y: C._sim.pins.get(TOP2).y },
        { x: xNot - 30, y: C._sim.pins.get(X2_AND_BOT.pins.inB).y }
      ]);
      // OR (module 2): 20px to the right of the AND pair, L-shaped feeds
      {
        const oT = C._sim.pins.get(X2_AND_TOP.pins.out);
        const oB = C._sim.pins.get(X2_AND_BOT.pins.out);
        const S = 0.75; const mid = (oT.y + oB.y)/2; const yOr = mid - 36*S;
        const xOr = oT.x + 20;
        const X2_OR = C.addOR('X2_XOR_OR', xOr, yOr, S);
        const iA = C._sim.pins.get(X2_OR.pins.inA);
        const iB = C._sim.pins.get(X2_OR.pins.inB);
        C.addWire(X2_AND_TOP.pins.out, X2_OR.pins.inA, [ {x:oT.x, y:iA.y}, {x:iA.x-6, y:iA.y} ]);
        C.addWire(X2_AND_BOT.pins.out, X2_OR.pins.inB, [ {x:oB.x, y:iB.y}, {x:iB.x-6, y:iB.y} ]);
      }
    })();
    // --- XOR Module 12: OR1 (top) XOR OR2 (bottom) ---
    (function(){
      const S = 0.75, h = 72*S; const pin = r=>C._sim.pins.get(r);
      // Get the two module OR outputs
      const OR1 = C._sim.comps.get('X1_XOR_OR');
      const OR2 = C._sim.comps.get('X2_XOR_OR');
      if(!OR1 || !OR2){ return; }
      const pO1 = pin(OR1.pins.out), pO2 = pin(OR2.pins.out);

      // Match module-1 NOT separation (~40px)
      let sep = 40; const pM1a = C._sim.pins.get('X1_NOT_A1.in'), pM1b = C._sim.pins.get('X1_NOT_IN1.in');
      if (pM1a && pM1b) sep = Math.abs(pM1a.y - pM1b.y);

      // Choose NOT input Ys so the vertical legs from each OR output are equal length
      const delta = pO2.y - pO1.y; // distance between source lines
      const L = Math.max(0, (delta - sep)/2);
      const yTopT = pO1.y + L;     // move down from top by L
      const yBotT = pO2.y - L;     // move up from bottom by L

      // Place the new NOTs in a fresh column to the right of both ORs
      const xNot = Math.max(pO1.x, pO2.x) + 110;
      const N12_TOP = C.addNOT('X12_NOT_TOP', xNot, yTopT - h/2, S);
      const TOP12 = C.addJunction('X12_TOP_BEHIND', xNot - 30, yTopT);
      C.addWire(OR1.pins.out, TOP12, [ {x:pO1.x, y:yTopT}, {x:xNot-30, y:yTopT} ]);
      C.addWire(TOP12, N12_TOP.pins.in, [ {x:xNot-6, y:yTopT} ]);

      const N12_BOT = C.addNOT('X12_NOT_BOT', xNot, yBotT - h/2, S);
      const BOT12 = C.addJunction('X12_BOT_BEHIND', xNot - 60, yBotT);
      C.addWire(OR2.pins.out, BOT12, [ {x:pO2.x, y:yBotT}, {x:xNot-60, y:yBotT} ]);
      C.addWire(BOT12, N12_BOT.pins.in, [ {x:xNot-6, y:yBotT} ]);

      // Two ANDs aligned to NOT outputs
      const oT = pin(N12_TOP.pins.out), oB = pin(N12_BOT.pins.out);
      const X12_AND_TOP = C.addAND('X12_AND_TOP', oT.x + 30, oT.y - 64*S, S);
      const X12_AND_BOT = C.addAND('X12_AND_BOT', oB.x + 30, oB.y - 8*S,  S);
      C.addWire(N12_TOP.pins.out, X12_AND_TOP.pins.inB);
      C.addWire(N12_BOT.pins.out, X12_AND_BOT.pins.inA);

      // Spines without extra nodes (only 30/60px behind-NOT dots)
      C.addWire(BOT12, X12_AND_TOP.pins.inA, [ {x:xNot - 60, y: pin(BOT12).y }, {x:xNot - 60, y: pin(X12_AND_TOP.pins.inA).y } ]);
      C.addWire(TOP12, X12_AND_BOT.pins.inB, [ {x:xNot - 30, y: pin(TOP12).y }, {x:xNot - 30, y: pin(X12_AND_BOT.pins.inB).y } ]);      // OR to combine the two ANDs, 20px to the right
      {
        const o1 = pin(X12_AND_TOP.pins.out), o2 = pin(X12_AND_BOT.pins.out);
        const mid = (o1.y + o2.y)/2; const yOr = mid - 36*S; const xOr = o1.x + 20;
        const X12_OR = C.addOR('X12_XOR_OR', xOr, yOr, S);
        const iA = pin(X12_OR.pins.inA), iB = pin(X12_OR.pins.inB);
        C.addWire(X12_AND_TOP.pins.out, X12_OR.pins.inA, [ {x:o1.x, y:iA.y}, {x:iA.x-6, y:iA.y} ]);
        C.addWire(X12_AND_BOT.pins.out, X12_OR.pins.inB, [ {x:o2.x, y:iB.y}, {x:iB.x-6, y:iB.y} ]);
      }
    })();

    // --- XOR Module 3: AND4B (top) XOR AND5B (bottom) ---
    (function(){
      const S = 0.75, h = 72*S; const pin = r=>C._sim.pins.get(r);
      const xNot = COL.AND2 + 120;
      const topRef = AND4B.pins.out, botRef = AND5B.pins.out;
      const pTop = pin(topRef), pBot = pin(botRef); if(!pTop || !pBot){ C.render && C.render(); return; }

      // Match NOT spacing to Module 1 (~40px apart)
      let sep1 = 40; const pM1a = C._sim.pins.get('X1_NOT_A1.in'); const pM1b = C._sim.pins.get('X1_NOT_IN1.in');
      if (pM1a && pM1b) sep1 = Math.abs(pM1a.y - pM1b.y);
      const mid3 = (pTop.y + pBot.y) / 2; const yTopT = mid3 - sep1/2; const yBotT = mid3 + sep1/2;

      // NOTs + behind nodes (30px for top, 60px for bottom)
      const N3_TOP = C.addNOT('X3_NOT_TOP', xNot, yTopT - h/2, S);
      const TOP3 = C.addJunction('X3_TOP_BEHIND', xNot - 30, yTopT);
      C.addWire(topRef, TOP3, [ {x: pin(topRef).x, y: yTopT}, {x:xNot-30, y:yTopT} ]);
      C.addWire(TOP3, N3_TOP.pins.in, [ {x:xNot-6, y:yTopT} ]);

      const N3_BOT = C.addNOT('X3_NOT_BOT', xNot, yBotT - h/2, S);
      const BOT3 = C.addJunction('X3_BOT_BEHIND', xNot - 60, yBotT);
      C.addWire(botRef, BOT3, [ {x: pin(botRef).x, y: yBotT}, {x:xNot-60, y:yBotT} ]);
      C.addWire(BOT3, N3_BOT.pins.in, [ {x:xNot-6, y:yBotT} ]);

      // Two XOR ANDs aligned to NOT outputs
      const oTop = pin(N3_TOP.pins.out), oBot = pin(N3_BOT.pins.out);
      const X3_AND_TOP = C.addAND('X3_AND_TOP', oTop.x + 30, oTop.y - 64*S, S);
      const X3_AND_BOT = C.addAND('X3_AND_BOT', oBot.x + 30, oBot.y - 8*S,  S);
      C.addWire(N3_TOP.pins.out, X3_AND_TOP.pins.inB);
      C.addWire(N3_BOT.pins.out, X3_AND_BOT.pins.inA);

      // Spines without extra nodes (only the 30/60px behind-NOT dots remain)
      C.addWire(TOP3, X3_AND_BOT.pins.inB, [
        { x: xNot - 30, y: pin(TOP3).y },
        { x: xNot - 30, y: pin(X3_AND_BOT.pins.inB).y }
      ]);
      C.addWire(BOT3, X3_AND_TOP.pins.inA, [
        { x: xNot - 60, y: pin(BOT3).y },
        { x: xNot - 60, y: pin(X3_AND_TOP.pins.inA).y }
      ]);
      // OR (module 3): 20px to the right of the AND pair, L-shaped feeds
      {
        const oT = C._sim.pins.get(X3_AND_TOP.pins.out);
        const oB = C._sim.pins.get(X3_AND_BOT.pins.out);
        const S = 0.75; const mid = (oT.y + oB.y)/2; const yOr = mid - 36*S;
        const xOr = oT.x + 20;
        const X3_OR = C.addOR('X3_XOR_OR', xOr, yOr, S);
        const iA = C._sim.pins.get(X3_OR.pins.inA);
        const iB = C._sim.pins.get(X3_OR.pins.inB);
        C.addWire(X3_AND_TOP.pins.out, X3_OR.pins.inA, [ {x:oT.x, y:iA.y}, {x:iA.x-6, y:iA.y} ]);
        C.addWire(X3_AND_BOT.pins.out, X3_OR.pins.inB, [ {x:oB.x, y:iB.y}, {x:iB.x-6, y:iB.y} ]);
      }
    })();

    // --- XOR Module 23: OR2 (top, unused for now) XOR OR3 (bottom) ---
    (function(){
      const S = 0.75, h = 72*S; const pin = r=>C._sim.pins.get(r);
      const OR2 = C._sim.comps.get('X2_XOR_OR');
      const OR3 = C._sim.comps.get('X3_XOR_OR');
      if(!OR2 || !OR3){ C.render && C.render(); return; }
      const pO2 = pin(OR2.pins.out), pO3 = pin(OR3.pins.out);

      // Use Module 1's NOT spacing (fallback 40)
      let sep = 40; const pM1a = C._sim.pins.get('X1_NOT_A1.in'), pM1b = C._sim.pins.get('X1_NOT_IN1.in');
      if (pM1a && pM1b) sep = Math.abs(pM1a.y - pM1b.y);

      // Equalize vertical legs: choose target Ys midway so both inputs would need same L-length (top left unconnected for now)
      const delta = pO3.y - pO2.y; const L = Math.max(0, (delta - sep)/2);
      const yTopT = pO2.y + L; // where top input would land
      const yBotT = pO3.y - L; // where bottom input will land

      // Place NOTs midway between modules 2 & 3 (x column to the right of both ORs)
      const xNot = Math.max(pO2.x, pO3.x) + 110;
      const N23_TOP = C.addNOT('X23_NOT_TOP', xNot, yTopT - h/2, S);
      const TOP23   = C.addJunction('X23_TOP_BEHIND', xNot - 30, yTopT);
      // Top input intentionally left unconnected for now; only behind-node exists
      

      const N23_BOT = C.addNOT('X23_NOT_BOT', xNot, yBotT - h/2, S);
      const BOT23   = C.addJunction('X23_BOT_BEHIND', xNot - 60, yBotT);
      // Connect ONLY Module 3 output to bottom behind-node with an equal-length L-bend
      C.addWire(OR3.pins.out, BOT23, [ {x:pO3.x, y:yBotT}, {x:xNot-60, y:yBotT} ]);
      C.addWire(BOT23, N23_BOT.pins.in, [ {x:xNot-6, y:yBotT} ]);
      // Ensure TOP23 feeds the top NOT (was missing)

      // Connect Module 4 (X12_XOR_OR) to Module 5 top input from above (equal-leg L-bend)
      {
        const OR4 = C._sim.comps.get('X12_XOR_OR');
        if (OR4){
          const pO4 = pin(OR4.pins.out);
          const mid0 = (pin(N23_TOP.pins.in).y + pin(N23_BOT.pins.in).y) / 2;
          const yMid = (pO4.y + mid0) / 2;
          const xTop = pin(TOP23).x;
          const yTop = pin(TOP23).y;
          // Down from OR4 to yMid, left to xTop, then down to TOP23 (no extra nodes)
          C.addWire(OR4.pins.out, TOP23, [ {x:pO4.x, y:yMid}, {x:xTop, y:yMid}, {x:xTop, y:yTop} ]);
          // attach TOP23 â†’ N23_TOP after the source is connected so it's driven in the same tick
          C.addWire(TOP23, N23_TOP.pins.in, [ {x:xNot-6, y:yTopT} ] );
        }
      }

      // ANDs aligned to NOT outputs
      const oT = pin(N23_TOP.pins.out), oB = pin(N23_BOT.pins.out);
      const X23_AND_TOP = C.addAND('X23_AND_TOP', oT.x + 30, oT.y - 64*S, S);
      const X23_AND_BOT = C.addAND('X23_AND_BOT', oB.x + 30, oB.y - 8*S,  S);
      C.addWire(N23_TOP.pins.out, X23_AND_TOP.pins.inB);
      C.addWire(N23_BOT.pins.out, X23_AND_BOT.pins.inA);

      // Spines (only required behind nodes to the left):
      C.addWire(BOT23, X23_AND_TOP.pins.inA, [ {x:xNot - 60, y: pin(BOT23).y }, {x:xNot - 60, y: pin(X23_AND_TOP.pins.inA).y } ]);
      C.addWire(TOP23, X23_AND_BOT.pins.inB, [ {x:xNot - 30, y: pin(TOP23).y }, {x:xNot - 30, y: pin(X23_AND_BOT.pins.inB).y } ]);

// OR to combine the two ANDs, 20px to the right
{
  // 1) Get the two AND outputs first
  const o1 = pin(X23_AND_TOP.pins.out);
  const o2 = pin(X23_AND_BOT.pins.out);

  // 2) Place the OR using those positions
  const mid = (o1.y + o2.y) / 2;
  const yOr = mid - 36 * S;
  const xOr = o1.x + 20;
  const X23_OR = C.addOR('X23_XOR_OR', xOr, yOr, S);

  // 3) Now get the OR inputs and wire with clean L-bends
  const iA = pin(X23_OR.pins.inA);
  const iB = pin(X23_OR.pins.inB);
  C.addWire(X23_AND_TOP.pins.out, X23_OR.pins.inA, [{ x: o1.x, y: iA.y }, { x: iA.x - 6, y: iA.y }]);
  C.addWire(X23_AND_BOT.pins.out, X23_OR.pins.inB, [{ x: o2.x, y: iB.y }, { x: iB.x - 6, y: iB.y }]);
}

    })();

// === PRIME DISPLAY ===
(function(){
  const C   = window.Circuit; if(!C) return;
  const sim = C._sim;

  const ORf = sim.comps.get('X23_XOR_OR');   // final OR before the display
  if(!ORf) return;

  const pOut = sim.pins.get(ORf.pins.out);
  const DISP = C.addDisplay('PRIME_DISPLAY', pOut.x + 20, pOut.y - 18, 132, 36);

  // No via needed: yâ€™s are equal, so this becomes a proper horizontal tangent
  C.addWire(ORf.pins.out, DISP.pins.in);
})();


C.render && C.render();
  })();
</script>
